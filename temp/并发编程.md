sudo -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17

grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}'| sort | uniq -c

熟练使用jmap、jstack、jconsole



性能角度：

1. 通过单机多机提升性能
2. 考虑机器资源限制



JAVA未使用PV，而是封装了monitor， monitor是基于PV的OO封装，减少出错几率？

https://blog.csdn.net/Dylan_Frank/article/details/79929567     底层

https://blog.csdn.net/Dylan_Frank/article/details/79965871     

https://blog.csdn.net/Dylan_Frank/article/details/79982752 管程

https://www.cnblogs.com/Brake/p/Operating_System_Monitor.html

https://www.cnblogs.com/alinh/p/6905221.html 这个讲的是锁和同步  锁可以看做二元semophore，我理解就是semophore的特例，本质没有什么不同，但是底层另外进行了新的实现。



https://www.jianshu.com/p/6fe4bc3374a2 java管程 

https://www.jianshu.com/p/f83ae055b6aa java lock和retreetlock

https://www.jianshu.com/p/82bdd60ff816  java多线程 Conditon



http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about 操作系统的学堂在线



condition，既然PV原语实现了生产者消费者，那么



java thread的blocked和waiting的区别：

https://blog.csdn.net/teaey/article/details/20059129

When a thread calls Object.wait method, it releases all the acquired monitors and is put into WAITING (or TIMED_WAITING if we call the timeout versions of the waitmethod) state. Now when the thread is notified either by notify() or bynotifyAll() call on the same object then the waiting state of the thread ends and the thread starts attempting to regain all the monitors which it had acquired at the time ofwait call. At one time there may be several threads trying to regain (or maybe gain for the first time) their monitors. If more than one threads attempt to acquire the monitor of a particular object then only one thread (selected by the JVM scheduler) is granted the monitor and all other threads are put into BLOCKED state. Got the difference? 

临界区是只有window下才有的数据结构。

在底层基础上，应用于不同场景，有同步的ECF semophore、锁、condition，再高一层的封装有monitor





| 操作系统 | 创建               | 加锁                | 解锁                 | 销毁                  |
| -------- | ------------------ | ------------------- | -------------------- | --------------------- |
| Win32    | CreateMutex        | WaitForSingleObject | ReleaseMutex         | CloseHandle           |
| Linux    | pthread_mutex_init | pthread_mutex_lock  | pthread_mutex_unlock | pthread_mutex_destroy |
| Solaris  | mutex_init         | mutex_lock          | mutex_unlock         | mutex_destroy         |

管程由四部分组成：

1.管程内部的共享变量。 

2.管程内部的条件变量。

3.管程内部并行执行的进程。

4.对于局部与管程内部的共享数据设置初始值的语句。  



##原子操作：

这里就是cpu内存底层的知识了。

CPU 内存、缓存图， 总线锁和缓存锁，这是当今多核CPU必备知识。这是一个本质和抽象关系



CAS,compare and swap CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。 



CPU的CAS指令 

java.util.concurrent包完全建立在CAS之上的 



