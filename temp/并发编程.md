sudo -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17

grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}'| sort | uniq -c

熟练使用jmap、jstack、jconsole



性能角度：

1. 通过单机多机提升性能
2. 考虑机器资源限制



JAVA未使用PV，而是封装了monitor， monitor是基于PV的OO封装，减少出错几率？

https://blog.csdn.net/Dylan_Frank/article/details/79929567     底层

https://blog.csdn.net/Dylan_Frank/article/details/79965871     

https://blog.csdn.net/Dylan_Frank/article/details/79982752 管程

https://www.cnblogs.com/Brake/p/Operating_System_Monitor.html

https://www.cnblogs.com/alinh/p/6905221.html 这个讲的是锁和同步  锁可以看做二元semophore，我理解就是semophore的特例，本质没有什么不同，但是底层另外进行了新的实现。



https://www.jianshu.com/p/6fe4bc3374a2 java管程 

https://www.jianshu.com/p/f83ae055b6aa java lock和retreetlock

https://www.jianshu.com/p/82bdd60ff816  java多线程 Conditon



http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about 操作系统的学堂在线



condition，既然PV原语实现了生产者消费者，那么



java thread的blocked和waiting的区别：

https://blog.csdn.net/teaey/article/details/20059129

When a thread calls Object.wait method, it releases all the acquired monitors and is put into WAITING (or TIMED_WAITING if we call the timeout versions of the waitmethod) state. Now when the thread is notified either by notify() or bynotifyAll() call on the same object then the waiting state of the thread ends and the thread starts attempting to regain all the monitors which it had acquired at the time ofwait call. At one time there may be several threads trying to regain (or maybe gain for the first time) their monitors. If more than one threads attempt to acquire the monitor of a particular object then only one thread (selected by the JVM scheduler) is granted the monitor and all other threads are put into BLOCKED state. Got the difference? 

临界区是只有window下才有的数据结构。

在底层基础上，应用于不同场景，有同步的ECF semophore、锁、condition，再高一层的封装有monitor





| 操作系统 | 创建               | 加锁                | 解锁                 | 销毁                  |
| -------- | ------------------ | ------------------- | -------------------- | --------------------- |
| Win32    | CreateMutex        | WaitForSingleObject | ReleaseMutex         | CloseHandle           |
| Linux    | pthread_mutex_init | pthread_mutex_lock  | pthread_mutex_unlock | pthread_mutex_destroy |
| Solaris  | mutex_init         | mutex_lock          | mutex_unlock         | mutex_destroy         |

管程由四部分组成：

1.管程内部的共享变量。 

2.管程内部的条件变量。

3.管程内部并行执行的进程。

4.对于局部与管程内部的共享数据设置初始值的语句。  



##原子操作：

这里就是cpu内存底层的知识了。

CPU 内存、缓存图， 总线锁和缓存锁，这是当今多核CPU必备知识。这是一个本质和抽象关系



CAS,compare and swap CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。 



CPU的CAS指令 

java.util.concurrent包完全建立在CAS之上的 





### JAVA内存模型

- JM内存模型类似于多核CPU
- 重排序，重排序有编译器重排序、指令级并行重排序、内存系统重排序，重排序会导致可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排
  序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要
  求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为
  Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。
- JMM用内存屏障保证顺序，LoadLoadBarier、StoreStoreBarier、LoadStoreBarier、StoreLoadBarier
- 与程序员密切相关的happens-before规则如下。
  ·程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
  ·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
  ·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的
  读。
  ·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
- as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）
  程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。



####顺序一致性

1）一个线程中的所有操作必须按照程序的顺序来执行。
2）（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内
存模型中，每个操作都必须原子执行且立刻对所有线程可见。



#### unsafe

Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的**原子操作** 这个类尽管里面的方法都是public的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类的方法的解释。总而言之，对于Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。 

```
compareAndSwapInt CPU指令
```

通过该指令可以设计轻量级自旋锁，并且该设计是针对多核设计，如果是单核，有没有该设计都一样。所以后面理解这些东西的时候，都需要按照多核来理解。



#### LockSupport

- ```
  park: Disables the current thread for thread scheduling purposes unless the
  permit is available
  if the thread is interupt\unpark
  ```

- ```
  Makes available the permit for the given thread, if it
   was not already available
  ```



#### condition

condition和c中cond语义一样



### AbstractQueuedSynchronizer

Node是个静态内部类：

**静态内部类**

1、只有内部类才能声明为static，也可以说是静态内部类 
2、只有静态内部类才能拥有静态成员，普通内部类只能定义普通成员 
3、静态类跟静态方法一样，只能访问其外部类的静态成员 
4、如果在外部类的静态方法中访问内部类，这时候只能访问静态内部类



这个类 是 Doug Lea作为Lock\Semophore\CoutDownLauch等的实现基础，使用这个类，进行了各种抽象。



- ```
  Subclasses should be defined as non-public internal helper
  classes that are used to implement the synchronization properties
  of their enclosing class
  可以看到各种抽象实现都有一个内部类syn继承这个类
  ```

- `This class supports either or both a default <em>exclusive</em>* mode and a <em>shared</em> mode. When acquired in exclusive mode,* attempted acquires by other threads cannot succeed. Shared mode* acquires by multiple threads may (but need not) succeed`

- `This class defines a nested {@link ConditionObject} class that* can be used as a {@link Condition} implementation by subclasses* supporting exclusive mode`

- ```
  To use this class as the basis of a synchronizer, redefine the following methods
  - tryAcquire
  - tryRelease
  - tryAcquireShared
  - tryReleaseShared
  - isHeldExclusively
  ```

- CLH锁即Craig, Landin, and Hagersten (CLH) locks，CLH锁是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。

  CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。

- ```
  A
  * "status" field in each node keeps track of whether a thread
  * should block.  A node is signalled when its predecessor
  * releases.
  ```