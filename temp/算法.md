https://algs4.cs.princeton.edu/home/ 算法 第4版本

 <http://mitpress.mit.edu/algorithms/ 算法导论

http://open.163.com/special/opencourse/algorithms.html 麻省理工的公开课

https://www.cnblogs.com/slgkaifa/p/6947094.html 一个中国学生学习算法的过程，值得一看



## 算法分析

algorithm is about perf， perf  like cash， 算法是关于性能的，性能像钱一样，是最底层的东西

algorithm is common lauguage in computer



(1) 老外下概念还是非常精准的，一般的每个程序可以用best\worst\average case time complexity 和amortized time complexity。但是一般我们都考虑N趋近于无穷大的情况，如果趋近于无穷大，则用asymptotic complexity来表达。对于这两者概念还是有较大区别的，对于asymptotic这种情况，mit的课程已经给出了数学定义、定理公式、recursive tree的分析方法、归纳递归等

https://en.wikipedia.org/wiki/Computational_complexity  wiki上算法分析

- worst case(usally): max time on any input pef
- average case: expected time on any input of size
- best case: min time on any input 





(2) asymtotic complexity:   N趋近于无穷大

https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/





## section 2:

### notation

介绍了三种符号的数学表达：

- 表达的是上界

![img](file:/../introducetoalgorithm/Onotation.png)

- 表达下界限

![img](file:/../introducetoalgorithm/Wnotation.png)

- 表达渐进

  ![img](file:/../introducetoalgorithm/thetanotation.png)

  对于这几种数学定义，不能简单的用归纳

  





### caculate

介绍了三种符号的数学表达：









# divide and conquer paradiam

- merge sort

- binary search  find x in array

  1. compare x with the middle element  of array
  2. conquer: recurse in one subarray
  3. combine: do nothing 

  T(n) = T(n/2) + theta(1) = theta(lgn)

- x^n

  x^n = x^(n/2) *x^(n/2)   for n is odd

  x^n = x^((n-1)/2) *x^((n-1)/2) *x  for n is even

  T(n) = T(n/2) + theta(1) = theta(lgn)

- f(n) = f(n - 1) + f(n - 2)  if (n > 2) for f(0) = 1 f(1) = 1

  - recursive是是指数级

  - 1 1 2 3 ... down-up大概 O(n)

  -  thero: fib(n) = （1  1

    ​                               1 0)  ^ n，这样就可以使用上述x^n的方法。 就是lg(n)

  ​         证明这个定理用induction

  ​	Base: (1 1            (F2     F1

  ​                    1 0) ^1 =   F1      F0)^1

​	        step1:（Fn+1     Fn             Fn    Fn-1       (1    1           (1    1

​                              Fn           Fn-1) = ( Fn-1 Fn-2)  *     1   0)  =       1      0)^(n - 1)

- 
- 
- 
- 
- 



# 树

看了一下 https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079?fromtitle=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&fromid=7077965&fr=aladdin 非常之多。

二叉树、

自平衡二叉树

B树

trie

### 二叉查找树

二叉排序树或者是一棵空树，或者是具有下列性质的[二叉树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91)：

（1）若左子树不空，则左子树上所有结点的值均小于它的[根结](https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93)点的值；

（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；

（3）左、右子树也分别为二叉排序树；

（4）没有键值相等的节点。



###红黑树

- **红黑树的特性**:
  **（1）每个节点或者是黑色，或者是红色。**
  **（2）根节点是黑色。**
  **（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
  **（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
  **（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

  **注意**：
  (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
  (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。







- 

   







